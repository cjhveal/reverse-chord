{
  "name": "piu",
  "version": "0.0.10",
  "description": "Infer/Recognize chords from collections of notes",
  "keywords": [
    "music",
    "jazz",
    "chords",
    "notes",
    "analytic"
  ],
  "main": "index.js",
  "author": {
    "name": "Jakob Miland",
    "email": "saebekassebil",
    "url": "https://github.com/saebekassebil"
  },
  "scripts": {
    "test": "vows test/*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/saebekassebil/piu"
  },
  "license": {
    "type": "MIT",
    "url": "https://raw.github.com/saebekassebil/piu/master/LICENSE"
  },
  "peerDependencies": {
    "teoria": ">=0.3.5"
  },
  "devDependencies": {
    "vows": ">=0.6.0"
  },
  "readme": "# più\n - *adverb \\\\ˈpyü, pē-ˈü\\\\*\n\nLet's infer some chord names from collections of notes, shall we?\n\n\nInstall with npm:\n\n    $ npm install piu\n\nYou'll most likely use this library with [teoria](https://github.com/saebekassebil/teoria)\n(as all the methods but `piu.name()` depends on objects from `teoria`),\nso let's install that too:\n\n    $ npm install teoria\n\nAnd now, you're ready to infer triads, chord extensions and names!\n\n```javascript\n// Infer the chords (strictly) constituted by the notes D, F, A, C\npiu\n  .infer( ['d', 'f', 'a', 'c'].map(teoria.note) )\n  .map( piu.name );\n// -> ['Dm7', 'F6']\n\n// Infer the chords (enharmonically) constituted by the notes B, D, F and Ab\npiu\n  .infer( ['b', 'd', 'f', 'ab'].map(teoria.note) )\n  .map( piu.name );\n// -> ['Dm6b5', 'Bdim7', 'Ddim7', 'Fm6b5' ... ]\n```\n\n**DISCLAIMER**: The `piu.name()` method will (for now) only recognize\npower-chords, triads and tetrads (that is, chords consisting of 2, 3 or 4 notes)\n\n## API\n\n### piu.triads(notes) -> Array of `triad`s\nThis method returns an `array` all the triads that the `notes` array constitutes.\n\nEach `triad` object has two properties:\n\n - `notes` - An array of the notes (`TeoriaNote`), ordered as tonic, third, fifth\n - `type` - The \"type\"/quality of the chord, which is one of:\n   - `''` for major\n   - `'m'` for minor\n   - `'aug'` for augmented\n   - `'dim'` for diminished\n   - `'sus2'` for suspended second\n   - `'sus4'` for suspended fourth\n   - All of above + `'#5'` or `'b5'` for fifth alterations\n\n### piu.infer(notes, enharmonic) -> Array of `chord`s\nThis method returns an `array` of all the chords that the `notes` array constitutes.\n\nIf *enharmonic* is `true`, all enharmonic chords will be returned as well.\nOtherwise the inferring defaults to \"strict\" chord inferring which will only\nreturn chords that consists of **exactly** the given notes.\n\n```javascript\n// Default is strict inferring\npiu.infer(['d', 'f', 'ab', 'cb'].map(teoria.note)).map(piu.name);\n// -> [ 'Ddim7', 'Fm6b5' ]\n\n// Enable enharmonic inferring\npiu.infer(['d', 'f', 'ab', 'cb'].map(teoria.note), true).map(piu.name);\n// -> [ 'Ddim7', 'Fm6b5', 'Dm6b5', 'Bdim7', 'Bm6b5', 'G#dim7', 'G#m6b5', ... ]\n```\n\nEach `chord` object has three properties:\n\n - `root` - A string representation of the root note (octave-less)\n - `type` - The \"type\"/quality of the base triad of the chord (as described above)\n - `exts` - An `array` of intervals (`TeoriaInterval`), that extends the base triad\n\n### piu.name(chord) -> String notation of the chord\nThis method takes a `chord` object, like the one that `piu.infer` returns, and\nreturns a string representation of that chord.\n\n```javascript\n// You can use the piu.name() method directly:\npiu.name({\n  root: 'A',\n  type: 'm',\n  exts: [teoria.interval('m7')]\n});\n// -> 'Am7'\n\n// Select a result from piu.infer() and hand it along to piu.name()\npiu.name(\n  piu.infer(['c', 'e', 'g', 'bb'].map(teoria.note))[0]\n);\n// -> C7\n\n// Create an array of TeoriaNotes, and then map each possible chord to its name:\npiu.infer( ['d', 'e', 'g', 'bb'].map( teoria.note ) ).map( piu.name );\n// -> [ 'Gm6', 'Em7b5' ]\n```\n",
  "readmeFilename": "README.md",
  "_id": "piu@0.0.10",
  "dist": {
    "shasum": "f1ad87cb16d01ca90cee67f1659bc9a6f5a40afa"
  },
  "_from": "piu"
}
